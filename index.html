<!doctype html>
<html>

<head>
    <title>AppDynamics @ Brown</title>

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <link rel="stylesheet" href="css/reveal.min.css">
    <link rel="stylesheet" href="css/theme/default.css" id="theme">

    <!-- For syntax highlighting -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <!-- If the query includes 'print-pdf', use the PDF print sheet -->
    <script>
        document.write( '<link rel="stylesheet" href="css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
    </script>

    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->

</head>

<body>

<div class="reveal">

    <!-- Any section element inside of this container is displayed as a slide -->
    <div class="slides">
        <section>
            <h1>Making sense of big applications</h1>
            <h3>with AppDynamics</h3>
            <p>Matt Cannizzaro '08, Adam Cath '07</p>
        </section>

        <section>
            <h2>AppDynamics</h2>
            <ul>
                <li>Started in 2008</li>
                <li>Downtown SF</li>
                <li>300 employees</li>
                <li>What we do</li>
            </ul>
            <img src="images/appman.png"
                 style="float: right; background: none; border: none; box-shadow: none"/>
        </section>

        <section>
            <h2>Let's build a web app</h2>
            <img src="images/mono-app.png"
                 style="float: center; background: none; border: none; box-shadow: none;"/>
            <aside class="notes">
                Say you're building a web app. It might start small, but
                hopefully it will need to grow. You can get bigger and bigger
                boxes, until you hit the limit of what a single machine can
                handle. Then what? There's really only one choice: you
                need to distribute your application across multiple nodes. 
            </aside>
        </section>

        <section>
            <h3>Easier said than done</h3>
            <img src="images/dist-app.png"
                 style="float: center; background: none; border: none; box-shadow: none;"/>
            <aside class="notes">
                Writing a distributed application is not an easy task; there's
                a completely new set of engineering problems that you'll 
                need to tackle. Let's talk about one of these many problems:
                performance.
            </aside>
        </section>

        <section>
            <h3>Why performance matters</h3>
            <aside class="notes">
                There's a certain satisfaction in writing efficient, fast code.
                But fundamentally, why do you need to care about performance?
                Making good use of the infrastructure and resources that you
                have is important, but it's not (usually) 
                the most important thing.
                Your app exists to solve your users' problems, but users are
                impatient: if your app is slow, users will abandon it. This
                problem is particularly bad if users have many alternatives
                and the cost of switching is low. Think about booking a flight
                on a travel site. If one site is slow, it's really easy to
                try one of its competitors instead. If your app is a business,
                bad performance costs money.
            </aside>
        </section>

        <section>
            <h3>How you can measure performance?</h3>
            <aside class="notes">
                Once you realize that you care about performance, you'll want
                to understand how your app performs by measuring it. How
                might you go about doing that? It would be reasonable to
                start by collecting some data from each node your app is
                running on, like CPU and memory utilization, how often
                garbage collections are running, and things like that. This
                is better than nothing, but not by much. Users don't care
                about any of these things: they care about their experiences.
                It's almost certainly bad if 5% of your users have a poor
                experience with your app. Imagine if Google dropped one out of
                every twenty searches that you ran! But could you detect
                such a problem by looking at, say, CPU utilization? You'll
                need a deeper understanding before you can find and fix many
                types of problems.
            </aside>
        </section>

        <section>
            <h3>Your app is not static</h3>
            <aside class="notes">
                Traditionally, applications were deployed only a few times a
                year, and each deployment was a major event. The rise of the
                web and distributed applications has made it much easier to
                deploy more often, so it's not uncommon for developers to
                deploy new versions of their web apps multiple times in a
                single week. This is great news for users, who benefit from 
                new features and bug fixes, but it introduces new problems
                for performance monitoring. Since your app is constantly
                changing, your performance monitor needs to be able to
                quickly adapt to the new environment. A tool that requires
                lengthy or complex configuration slows you down and is not
                suitable for modern web application development.
            </aside>
        </section>

        <section>
            <h3>Requirements</h3>
                <ol>
                    <li>Distributed</li>
                    <li>Tells the story as your users experience it</li>
                    <li>Require minimal manual configuration</li>
                </ol>
            <aside class="notes">
                To recap, we need our performance monitor to be: <br/>
                    1. Distributed, because your app is. <br/>
                    2. Monitor your application performance, not the
                        infrastructure, because your users experience the app.
                        <br/>
                    3. Dynamically adapt to changes in your environment,
                        because you don't have time for configuration.
                    <br/><br/>
                    Okay, let's build it!
            </aside>
        </section>

        <section>
            <h2>Telling the story of a request</h2>
            <aside class="notes">
                We suspect that infrastructure monitoring is not enough, so
                how will we measure performance? Your users interact with
                your app over HTTP, so that's a logical place to start. If
                we know when a request arrives at your server, and when your
                server finishes sending the response, that's a decent
                measure your app's performance from the user's perspective.
                <br/>
                You know when requests arrive and when the corresponding
                responses are sent, so you can identify which requests are
                slow, or fail outright. This helps you know when your app
                is having problems, but it doesn't help you in figuring out
                why. How can we do that?
                <br/>
                Remember that your app is distributed, so before your app
                can respond to the user's request, it probably needs to make
                some requests of its own to various parts of your backend,
                receive and process the responses, and then generate the
                response that your user sees. Let's assume that all this
                communication happens over HTTP. Can we tie all these related
                HTTP requests and responses together, so that you can tell
                the full story of a single user request? What if we could
                somehow tag related requests with some identifying
                information?
            </aside>
        </section>

        <section>
            <h3>What we've got to work with</h3>
			<pre><code data-trim contenteditable>
GET /dumprequest HTTP/1.1
Host: djce.org.uk
Connection: keep-alive
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/29.0.1547.76 Safari/537.36
Referer: https://www.google.com/
Accept-Language: en-US,en;q=0.8
			</code></pre>
            <aside class="notes">
                Here's an example of an HTTP request. It has these interesting
                components: <br/>
                1. The HTTP method, like GET or PUT. <br/>
                2. The URI, which along with the method, helps you determine
                    what the user is requesting. <br/>
                3. The headers, which are essentially a list of key-value
                    pairs. <br/> 
                4. The request body, which is optional and could contain
                    arbitrary data. <br/> <br/>

                If we want to add some data to an HTTP request, headers are
                attractive, since we can easily add a header with some
                identifying information without changing the behavior of the
                rest of the application.
            </aside>
        </section>

        <section>
            <h3>Tag and follow</h3>
            <img src="images/flow-map.png"
                 style="float: center; background: none; border: none; box-shadow: none;"/>
            <aside class="notes">
                When a request from a user first arrives, start by generating
                a unique ID for it. At some point, the routine that is
                processing the user's request may make some requests to other
                nodes in your application. When this happens, add the unique
                ID as a header in the request. Using this method, we can
                discover every HTTP request and response that's involved in
                servicing a user's request, and if the user's request is
                slow, or encounters an error, we can determine where the
                problem lies.<br/><br/>
                Of course, out in the wild, you'll often find protocols other
                than HTTP being used in the backend. The same sort of
                principles apply for other protocols, but we won't get into
                the details today.
            </aside>
        </section>

        <section>
            <h3>Implementation</h3>
			<pre><code data-trim contenteditable>
public void send(Request req)
{
   if (Profiler.isInTransaction()) {
       // We are a middle node in a distributed transaction.
       requestID = Profiler.getCurrentTransactionID()
   } else {
       // We are the root node of a distributed transaction.
       requestID = Profiler.createTransactionID()
   }
   long startT = System.nanoTime()
   req.addHeader("REQUEST_ID", requestID)

   ...

   long endT = System.nanoTime()
   Profiler.reportRequest(req, endT - startT, requestID)
}
			</code></pre>
            <aside class="notes">
                Let's take a quick look at the implementation of the
                algorithm we just described. Here's the code we'd need to
                add to the routine that sends requests to tag outgoing
                requests.
            </aside>
        </section>

        <section>
            <h3>Implementation</h3>
			<pre><code data-trim contenteditable>
public void receive(Request req, Response res)
{
    if (req.hasHeader("REQUEST_ID"))
        Profiler.setCurrentTransaction(req.getHeader("REQUEST_ID"))
    ...
}
			</code></pre>
            <aside class="notes">
                And here's the code we'd need to add to the routine that
                handles incoming requests. <br/> <br/>

                Now that we know what we want to do, how can we do it? You
                could write this code in each part of your app that handles or
                makes HTTP requests that passes these identifiers between
                requests. It would be fairly straightforward, but tedious
                and error-prone. Worst of all, it makes it hard to add new
                code and nearly impossible to integrate a third party library.
                So what we can do?
            </aside>
        </section>

        <section>
            <h3>How your code runs</h3>
            <img src="images/code.png"
                 style="float: center; background: none; border: none; box-shadow: none;"/>
            <aside class="notes">
                For argument's sake, let's assume that your app is written
                in Java. It starts out as source code, which the Java compiler
                transforms into Java byte code during compilation. When it's
                time to run your program, you can't just run the byte code
                as is; your CPU doesn't understand byte code. So the Java
                Virtual Machine does another transformation, this time turning
                the byte code into native machine code. You'll recall that this
                step is called just-in-time compilation, or JITing.<br/><br/>
                
                Usually each step of this process preserves the behavior of
                your code, but you certainly could imagine a transformation
                that doesn't. A compiler or JIT that performed such a
                transformation would be considered buggy, but if you were
                careful, you could transform code in a way that 
                changes its behavior in a useful way while not interfering
                with the purpose of the program.<br/><br/>

                In theory, you could do your code transformation on either
                the source code, the byte code, or the machine code. Changing
                the source code would be a nightmare for the app developers,
                and doing machine code transformations would require altering
                the JVM and result in an implementation that's dependent
                on CPU architecture, so neither is particularly interesting.
                Java byte code, on the other hand, can be altered transparently,
                as far as developers are concerned, and by definition, is
                independent of any specific CPU architecture.
            </aside>
        </section>

        <section>
            <h3>Instrumenting an app</h3>
			<pre><code data-trim contenteditable>
public void sendHttpRequest(Request request) {
    ...
}
			</code></pre>
            <aside class="notes">
                Let's say that the method that implements HTTP requests in
                your app looks something like this. Since few apps
                re-implement this functionality from scratch, this method
                is probably part of a library. In order to instrument it,
                we need to transform the body of the method from this, into...
            </aside>
        </section>

        <section>
            <h3>Instrumenting an app</h3>
			<pre><code data-trim contenteditable>
public void sendHttpRequest(Request request) {
    Profiler.beginHttpRequest(request); 
    ...
    Profiler.endHttpRequest(request); 
}
			</code></pre>
            <aside class="notes">
                ... this. We can use a technique called byte code injection
                to perform this transformation at runtime. Here's how it works:
                when the JVM is running a program and it needs to find the
                definition of a class, it uses a special sort of object
                called a class loader. The JVM provides an API to hook into
                the class loading process so that your code is called after
                a class loader has found the definition of a class, but
                before that class's definition is available to the rest of
                the program. We use this opportunity to examine 
                the class being loaded, and if it happens to be a class that
                we are interested in instrumenting, we write new byte code
                into the bodies of its methods. <br/> <br/>

                Now that we are running instrumentation code at the beginning
                and end of each interesting method, we can keep track of how
                long each HTTP request takes, and write identifying information
                into the request headers as well. This is all we need to
                implement the tag and follow scheme for instrumenting HTTP.
                <br/> <br/>

                This technique is fundamentally straightforward, but since
                our instrumentation code runs within the program being
                monitored, this part of our system, called the agent, needs
                to be thoughtfully engineered and tested. If the agent is
                buggy, it's very possible for it to bring an application down,
                which obviously defeats the whole purpose. Since the agents
                monitor apps in production, they also need to keep overhead
                to a minimum: we generally promise our customers no more than
                2% overhead on average. AppDynamics has agents for Java,
                .NET, PHP, and Javascript, and we will shortly have node.js,
                Android, and iOS agents as well. These agents work in
                different ways, but the goals and principles are similar.
            </aside>
        </section>

        <section>
            <h1>Making sense of the data</h1>
            <aside class="notes">
                In a production environment, there are many agents reporting
                quite a large amount of data. This means that we need to have
                a scalable way of collecting and aggregating all this data,
                and also need to have effective visualizations to help
                our users make sense of it. Let me show you our product and
                demo some of the basic features.

                Demo should cover: <br/>
                1. Flow map <br/>
                2. BTs <br/>
                3. Snapshots <br/>
                4. EUM <br/>
            </aside> 
        </section>

        <section>
            <h1>Unsolicited advice</h1>
            <p>Or, some things that you probably don't think matter, <br/>but actually really do matter.</p>
        </section>

        <section>
            <h2>1) Do code reviews</h2>
            <aside class="notes">
                This one seems small, but it's a really big deal.<br/>

                At Adobe, we rarely did code reviews. At AppDynamics, we do them on every commit. I know it sounds
                like a waste of time, but it really works. Apart from the short-term benefits (fewer bugs,
                knowledge sharing, etc), I have learned more about writing clear, beautiful, bug-free
                code in the last 9 months at AppDynamics than in the previous 5 years at Adobe. You'll write better
                code, but perhaps even more importantly, reviewing other people's code expands your perspective and
                forces you to examine your beliefs about what good code is.<br/>

                When you interview, ask about code reviews. It's very diagnostic. A culture that does code reviews
                is a culture that values quality and craftsmanship. That's the kind of place where you're really going
                to learn.<br/>
            </aside>
        </section>

        <section>
            <h2>2) Get real feedback</h2>
            <aside class="notes">
                The first product I worked on at Adobe was really cool. We got lots of feedback from potential customers:
                they thought it was really cool. I demoed it in this very room a few years ago, and your predecessors
                thought it was cool too. We worked hard on it for 3 years. Then we found out there was no real market
                for it because it didn't <i>really</i> fit into anyone's workflow.<br/>

                The "potential customers" didn't mention that part. We got bogus feedback.<br/>

                The second product I worked on, we did it right. We shipped a working version with a limited feature set
                within three months of starting the project (and one month was just bureaucracy). And people really
                started using it to solve their real problems. They filed bugs! They made feature requests. And we
                did what they asked. And they liked it. And we got more users. And it was glorious.<br/>

                So I've come to believe that the only feedback that's really worth anything is people really using
                your software for their real work.<br/>
                <br/>
            </aside>
        </section>

        <section>
            <h2>3) Learn tech that transfers</h2>
            <p>Not proprietary stacks.</p>
            <aside class="notes">
                One of the reasons that both Matt and I left Adobe is that we had become experts on Flash, which is
                a dead technology. When we applied to our next jobs, we basically had to apologize for that.
                Don't waste brain cells on dead technology.<br/>

                I would also be wary of proprietary technology. If you work at a big company, especially one with a
                bad case of "not invented here" syndrome, you'll be surrounded by layers of proprietary software in
                every direction. It can be really interesting tech, but it has virtually no value for the rest of your
                career.<br/>

                You might think "isn't it more important that I learn transferable skills, ideas, and principles?"
                Yes, that is very important; don't ignore it. But don't underestimate the value of knowing specific
                technologies.<br/>

                Here I need to make a plug for AppDynamics. If you work at Facebook, you can learn how
                Facebook's amazing PHP VM works. If you work at Google, you can learn how about Google's insanely
                scalable database works. But if you work at AppDynamics, you'll learn about how NetFlix works,
                how Williams-Sonoma works, how OpenTable works, how Roku works. Because our job is to undestand,
                and help our customers understand, how these very complex and interesting apps really work.<br/>
            </aside>
        </section>

        <section>
            <h2>4) Stay close to the business</h2>
            <p>Sorry, this means money.</p>
            <p>Full-stack visibility.</p>
            <aside class="notes">
                If you don't mind your project getting cancelled every few years, you can ignore this section.<br/>

                When I looked for my first job, I thought "I want to work on hard problems that improve the world
                with smart people". And most of my friends had the same criteria. It's very tempting to not worry
                too much about the business. But there are some business considerations that can have a material
                impact on your career.<br/>

                First, a very harsh reality: if you're not working on something that generates revenue, your project
                is expendable. It doesn't matter what your manager says. If the project you're working on does
                not solve some real problems for some real people who know they have these problems and are
                willing to pay you to solve them, it is a slave the fickle winds of company strategy. Today
                the CTO is coming around to your cube to check on the project; what's gonna happen after the
                quarterly earnings call when the analysts want to know why you're spending 10 million a year
                on Project Frobnicator?<br/>

                Second: It's really valuable talk to non-engineers on a regular basis.
                If you don't talk to the sales team, you really don't know anything about your business.
                The same goes for operations, customer support, and marketing.
                This will make you better at your job. It will make you more valuable to the company.
                You will learn a lot. And if you think you might want to start your own company some day,
                you'll have a huge advantage because you'll know how a business really works.
                Note that this is really hard to do in a big company.<br/>
            </aside>
        </section>

        <section>
            <h2>5) Think about your second job</h2>
            <aside class="notes">
                Right now, you're probably focused on getting your first job. To me, that first job, much like the
                first day of college, felt like a sort of information event horizon: it was simply impossible to know
                what would happen after the first job.<br/>

                And it's true. It's hard to know where tech will be in five years, or where your interests will
                lie, but one thing is pretty certain: you'll probably stay at your first job for a few years,
                and then move on to something else.<br/>

                The things you do and learn (and, of course, the people you meet) in your first job will get you your
                second job.<br/>

                So when you're sifting through your many job offers, ask yourself "am I going to learn stuff that will
                make me more valuable and help my career down the line?"<br/>
            </aside>
        </section>

        <section data-background="#14a45c">
            <img src="images/logo.png" style="padding: 20px; background: #ffffff;"/>
        </section>

    </div>

</div>

<script src="lib/js/head.min.js"></script>
<script src="js/reveal.min.js"></script>

<script>

    // Full list of configuration options available here:
    // https://github.com/hakimel/reveal.js#configuration
    Reveal.initialize({
                          controls: true,
                          progress: true,
                          history: true,
                          center: true,

                          theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
                          transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

                          backgroundTransition: 'slide',

                          // Optional libraries used to extend on reveal.js
                          dependencies: [
                              { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
                              { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                              { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                              { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
                              { src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
                              { src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
                          ]
                      });

</script>

</body>
</html>
